#![cfg(test)]
use Bridge::BridgeInstance;
use DemoERC20::DemoERC20Instance;
use ExmERC20::ExmERC20Instance;
use TestERC20::TestERC20Instance;
use alloy::{
    primitives::{Address, FixedBytes, U256, Uint},
    providers::{self, Provider, ProviderBuilder, fillers::FillProvider},
    rpc::types::Filter,
    signers::{k256::ecdsa::SigningKey, local::LocalSigner},
    sol_types::sol,
};
use alloy_contract::CallBuilder;
use alloy_sol_types::SolEvent;
use console::consoleInstance;
use eyre::{Context, ContextCompat, Result};
use futures_util::{
    StreamExt, TryFutureExt,
    future::{join_all, try_join, try_join_all},
};
use std::{
    fs,
    hash::{DefaultHasher, Hash, Hasher},
    path::PathBuf,
    str::FromStr,
};
use tokio::{
    sync::mpsc::{self, Sender},
    task::{JoinHandle, JoinSet},
    try_join,
};
use tracing_test::traced_test;

type Signer = LocalSigner<SigningKey>;

sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    #[derive(Debug, Hash)]
    Bridge,
    "contract/combined/Bridge.json"
);
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    #[derive(Debug, Hash)]
    console,
    "contract/combined/console.json"
);
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    #[derive(Debug, Hash)]
    DemoERC20,
    "contract/combined/DemoERC20.json",
);
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    #[derive(Debug, Hash)]
    TestERC20,
    "contract/combined/TestERC20.json",
);
sol!(
    #[allow(missing_docs)]
    #[sol(rpc)]
    #[derive(Debug, Hash)]
    ExmERC20,
    "contract/combined/ExmERC20.json",
);

const RPC_URL: &str = "http://localhost:8545";

#[derive(Debug)]
struct User<T, A>
where
    T: alloy::providers::fillers::TxFiller,
    A: alloy::providers::Provider + Clone,
{
    key: Signer,
    contracts: Contracts<T, A>,
    client: FillProvider<T, A>,
}

impl<T, A> User<T, A>
where
    T: alloy::providers::fillers::TxFiller,
    A: alloy::providers::Provider + Clone,
{
    async fn watch_logs(&self) -> Result<JoinHandle<()>> {
        let filter = Filter::new();
        let watch_send_event = self.client.watch_logs(&filter).await?;
        let handle = tokio::spawn(async move {
            let mut k = watch_send_event.into_stream();
            while let Some(logs) = k.next().await {
                for log in logs {
                    let Some(log_topic) = log.topic0() else {
                        continue;
                    };

                    match *log_topic {
                        Bridge::EventCreateBridge::SIGNATURE_HASH => {
                            let msg = log.log_decode::<Bridge::EventCreateBridge>().unwrap();
                            println!("Создание моста для ERC20");
                            println!("Log: {:#?}", msg.data());
                        }
                        Bridge::EventDeposit::SIGNATURE_HASH => {
                            let msg = log.log_decode::<Bridge::EventDeposit>().unwrap();
                            println!("Перевод ETH с l1=>l2");
                            println!("Log: {:#?}", msg.data());
                        }
                        Bridge::EventDepositRC20::SIGNATURE_HASH => {
                            let msg = log.log_decode::<Bridge::EventDepositRC20>().unwrap();
                            println!("Перевод ERC20 с l1=>l2");
                            println!("Log: {:#?}", msg.data());
                        }

                        DemoERC20::Approval::SIGNATURE_HASH => {
                            let msg = log.log_decode::<DemoERC20::Approval>().unwrap();
                            println!("Log: {:#?}", msg.data());
                        }
                        console::Vote::SIGNATURE_HASH => {
                            let msg = log.log_decode::<console::Vote>().unwrap();
                            println!("Log: {:#?}", msg.data());
                        }
                        console::VoteString::SIGNATURE_HASH => {
                            let msg = log.log_decode::<console::VoteString>().unwrap();
                            println!("Log: {:#?}", msg.data());
                        }
                        console::VoteAdderss::SIGNATURE_HASH => {
                            let msg = log.log_decode::<console::VoteAdderss>().unwrap();
                            println!("Log: {:#?}", msg.data());
                        }
                        console::VoteNumber::SIGNATURE_HASH => {
                            let msg = log.log_decode::<console::VoteNumber>().unwrap();
                            println!("Log: {:#?}", msg.data());
                        }
                        _ => (),
                    }
                }
            }
        });
        Ok(handle)
    }

    async fn deposit(&self, to: Address, amount: U256) -> Result<FixedBytes<32>> {
        // Транзакция перевода на L2
        self.contracts
            .bridge
            .deposit(to)
            .from(self.key.address())
            .value(amount)
            .send()
            .await
            .context("Ошибка при отправки транзакции")?
            .watch()
            .await
            .context("Ошибка при мониторинеге транзакции")
    }

    async fn deposit_event(&self, s: Sender<Bridge::EventDeposit>) -> Result<JoinHandle<()>> {
        let watch_send_event = self
            .contracts
            .bridge
            .EventDeposit_filter()
            .watch()
            .await
            .unwrap();
        let event_handle = tokio::spawn(async move {
            use futures_util::StreamExt;

            let mut k = watch_send_event.into_stream();
            while let Some(Ok((event, _l))) = k.next().await {
                s.send(event).await.unwrap();
            }
        });
        Ok(event_handle)
    }
}

#[derive(Debug)]
struct Contracts<T, A>
where
    T: alloy::providers::fillers::TxFiller,
    A: alloy::providers::Provider + Clone,
{
    bridge: BridgeInstance<FillProvider<T, A>>,
    console: consoleInstance<FillProvider<T, A>>,
    demo_erc20: DemoERC20Instance<FillProvider<T, A>>,
    test_erc20: TestERC20Instance<FillProvider<T, A>>,
    exm_erc20: ExmERC20Instance<FillProvider<T, A>>,
}

macro_rules! info_token {
    ($arg:expr) => {
        println!(
            "[{symbol}] {name} address: {address}",
            symbol = $arg.symbol().call().await.unwrap(),
            name = $arg.name().call().await.unwrap(),
            address = $arg.address()
        );
    };
}

fn read_accounts() -> Result<Vec<Signer>> {
    fn read_keystore_from_geth() -> Result<Vec<Signer>> {
        let keys_path = PathBuf::from_str("data/keystore").context("Путь до ключей не валиден")?;
        let keys = keys_path
            .read_dir()
            .context("Неудалось прочитать директорию")?
            .filter_map(|v| v.ok())
            .map(|v| v.path())
            .filter(|v| v.is_file())
            .inspect(|v| {
                dbg!(&v);
            })
            .map(|v| LocalSigner::decrypt_keystore(&v, ""))
            .filter_map(|v| v.ok())
            .collect::<Vec<_>>();

        Ok(keys)
    }

    let key_path = PathBuf::from_str("keys.private").unwrap();
    if !key_path.exists() {
        let keys = read_keystore_from_geth()?;

        let keys_bytes: Vec<_> = keys.iter().map(|v| v.to_bytes()).collect();
        let keys_json = serde_json::to_string_pretty(&keys_bytes)
            .context("Неудалось преобразовать ключ в JSON")?;
        fs::write(&key_path, keys_json).context("Ошибка при записи файла ключей")?;
        return Ok(keys);
    }

    let keys_json = fs::read_to_string(&key_path).context("Неудалось прочитать файл ключей")?;
    let keys_bytes = serde_json::from_str::<Vec<FixedBytes<32>>>(&keys_json)
        .context("Неудалось преобразовать JSON в ключи")?;
    keys_bytes
        .into_iter()
        .map(|v| LocalSigner::from_bytes(&v).context("Ошибка при преобразовании байтов в ключ"))
        .collect::<Result<Vec<_>>>()
}

async fn init_contracts<T, A>(provider: FillProvider<T, A>) -> Result<Contracts<T, A>>
where
    T: alloy::providers::fillers::TxFiller,
    A: alloy::providers::Provider + Clone,
{
    // check
    let hashs: [u64; 5] = [
        &Bridge::BYTECODE,
        &DemoERC20::BYTECODE,
        &TestERC20::BYTECODE,
        &ExmERC20::BYTECODE,
        &console::BYTECODE,
    ]
    .map(|byte_code| {
        let mut hasher = DefaultHasher::new();
        byte_code.hash(&mut hasher);
        hasher.finish()
    });

    let paths: Vec<PathBuf> = hashs
        .iter()
        .map(|hash| {
            PathBuf::from_str(&format!("/tmp/{hash}.address")).context("Невалидное имя для файла")
        })
        .collect::<Result<_>>()
        .unwrap();

    if paths.iter().all(|path| path.exists()) {
        let addresses = paths
            .iter()
            .map(|path| {
                let address_str = fs::read_to_string(path)
                    .context("При чтении адресса контракта произошла ошибка")?;
                address_str
                    .trim_end()
                    .parse::<Address>()
                    .context("Неудалось преобразовать строку в адрес")
            })
            .collect::<Result<Vec<_>>>()
            .unwrap();

        return Ok(Contracts {
            bridge: Bridge::new(addresses[0], provider.clone()),
            demo_erc20: DemoERC20::new(addresses[1], provider.clone()),
            test_erc20: TestERC20::new(addresses[2], provider.clone()),
            exm_erc20: ExmERC20::new(addresses[3], provider.clone()),
            console: consoleInstance::new(addresses[4], provider.clone()),
        });
    }

    let bridge_contract_client = Bridge::deploy(provider.clone()).await?;
    let bridge_contract_address = bridge_contract_client.address();
    println!("Deployed contract at address: {bridge_contract_address}",);
    fs::write(&paths[0], bridge_contract_address.to_string())
        .context("При записи адреса контракта произошла ошибка")?;

    let demo_erc20_contract_client = DemoERC20::deploy(provider.clone()).await?;
    let demo_erc20_contract_address = demo_erc20_contract_client.address();
    println!("Deployed contract at address: {demo_erc20_contract_address}",);
    fs::write(&paths[1], demo_erc20_contract_address.to_string())
        .context("При записи адреса контракта произошла ошибка")?;

    let test_erc20_contract_client = TestERC20::deploy(provider.clone()).await?;
    let test_erc20_contract_address = test_erc20_contract_client.address();
    println!("Deployed contract at address: {test_erc20_contract_address}",);
    fs::write(&paths[2], test_erc20_contract_address.to_string())
        .context("При записи адреса контракта произошла ошибка")?;

    let exm_erc20_contract_client = ExmERC20::deploy(provider.clone()).await?;
    let exm_erc20_contract_address = exm_erc20_contract_client.address();
    println!("Deployed contract at address: {exm_erc20_contract_address}",);
    fs::write(&paths[3], exm_erc20_contract_address.to_string())
        .context("При записи адреса контракта произошла ошибка")?;

    let console_contract_client = console::deploy(provider.clone()).await?;
    let console_contract_address = console_contract_client.address();
    println!("Deployed contract at address: {console_contract_address}",);
    fs::write(&paths[4], console_contract_address.to_string())
        .context("При записи адреса контракта произошла ошибка")?;

    Ok(Contracts {
        bridge: bridge_contract_client,
        demo_erc20: demo_erc20_contract_client,
        test_erc20: test_erc20_contract_client,
        exm_erc20: exm_erc20_contract_client,
        console: console_contract_client,
    })
}

#[cfg(test)]
mod tests {
    use super::{
        Bridge::BridgeInstance,
        DemoERC20::DemoERC20Instance,
        ExmERC20::ExmERC20Instance,
        Signer,
        TestERC20::TestERC20Instance,
        console::{self, consoleInstance},
    };
    use crate::{
        Bridge, Contracts, DemoERC20, ExmERC20, RPC_URL, TestERC20, User, init_contracts,
        read_accounts,
    };
    use alloy::{
        consensus::constants::ETH_TO_WEI,
        network::{EthereumWallet, TransactionBuilder},
        primitives::{
            Address, FixedBytes, U256, Uint,
            utils::{Unit, parse_ether},
        },
        providers::{
            self, Identity, Provider, ProviderBuilder, RootProvider,
            fillers::{
                BlobGasFiller, ChainIdFiller, FillProvider, GasFiller, JoinFill, NonceFiller,
                WalletFiller,
            },
        },
        rpc::types::{Filter, TransactionRequest},
        signers::{k256::ecdsa::SigningKey, local::LocalSigner},
        sol_types::sol,
    };
    use alloy_sol_types::{SolEvent, abi::token};
    use eyre::{Context, Result};
    use futures_util::{
        TryFutureExt,
        future::{join_all, try_join, try_join_all},
    };
    use rayon::iter::{IndexedParallelIterator, IntoParallelIterator, ParallelIterator};
    use std::{
        fs, future,
        hash::{DefaultHasher, Hash, Hasher},
        path::PathBuf,
        str::FromStr,
        time::Duration,
    };
    use tokio::{sync::mpsc, task::JoinSet, try_join};
    use tracing_test::traced_test;

    // тест используется для dev деплоя при изменении контракта
    #[traced_test]
    #[tokio::test]
    async fn test_depoloy_contracts() {
        let accounts: Vec<_> = read_accounts().unwrap().into_iter().take(3).collect();

        let porviders = try_join_all(
            accounts
                .clone()
                .into_iter()
                .map(|key| ProviderBuilder::new().wallet(key).connect(RPC_URL)),
        )
        .await
        .unwrap();

        let mut build_contracts = porviders.clone().into_iter().map(|p| init_contracts(p));
        let mut contracts = vec![build_contracts.next().unwrap().await.unwrap()];
        contracts.extend(try_join_all(build_contracts).await.unwrap());

        let mut users: [_; 3] = accounts
            .clone()
            .into_iter()
            .zip(contracts)
            .zip(porviders)
            .map(|((key, contracts), client)| User {
                key,
                contracts,
                client,
            })
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();

        // Пополнение у пользователей баланса ERC20 L1
        funds_erc20(&mut users).await;
    }

    #[traced_test]
    #[tokio::test]
    async fn test_bridge() {
        let accounts = read_accounts()
            .unwrap()
            .into_iter()
            .take(3)
            .collect::<Vec<_>>();

        let porviders = try_join_all(
            accounts
                .clone()
                .into_iter()
                .map(|key| ProviderBuilder::new().wallet(key).connect(RPC_URL)),
        )
        .await
        .unwrap();

        let mut build_contracts = porviders.clone().into_iter().map(|p| init_contracts(p));
        let mut contracts = vec![build_contracts.next().unwrap().await.unwrap()];
        contracts.extend(try_join_all(build_contracts).await.unwrap());

        let mut users: [_; 3] = accounts
            .clone()
            .into_iter()
            .zip(contracts)
            .zip(porviders)
            .map(|((key, contracts), client)| User {
                key,
                contracts,
                client,
            })
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();

        let baddr = users[0].contracts.bridge.address();
        let derc = users[0].contracts.demo_erc20.address();
        let terc = users[0].contracts.test_erc20.address();
        let eerc = users[0].contracts.exm_erc20.address();
        users.iter().for_each(|u| {
            assert_eq!(baddr, u.contracts.bridge.address());
            assert_eq!(derc, u.contracts.demo_erc20.address());
            assert_eq!(terc, u.contracts.test_erc20.address());
            assert_eq!(eerc, u.contracts.exm_erc20.address());
        });

        println!("owner: {}", users[0].key.address());
        println!("alice: {}", users[1].key.address());
        println!("bob: {}", users[2].key.address());
        println!("Bridge address: {}", users[0].contracts.bridge.address());
        info_token!(&users[0].contracts.demo_erc20);
        info_token!(&users[0].contracts.test_erc20);
        info_token!(&users[0].contracts.exm_erc20);

        // Мониторинг событий console
        let _console_handle = users[0].watch_logs().await.unwrap();

        // Перевод ETH l1=>l2
        test_bridge_deposit(&mut users).await;

        // Пополнение у пользователей баланса ERC20 L1
        funds_erc20(&mut users).await;

        // тестирование вызова контракта без моста ERC20 L1=>L2
        // Не должно проходить
        test_erc20_without_bridge(&mut users).await;

        // Создание моста для ERC20 между L1=>L2
        test_bridge_create_erc20(&mut users).await;

        return;

        // println!("# # # Тестирование вывода/withdrow на L1 ETH # # #");

        // let old_balance = owner.client.get_balance(owner.key.address()).await.unwrap();
        // print!("Резервирование средств для вывода: ");
        // let tx = owner
        //     .contracts
        //     .bridge
        //     .request_withdraw(alice.key.address())
        //     .value(Uint::from(1_000_000_000_000_000_u64))
        //     .send()
        //     .await
        //     .unwrap()
        //     .watch()
        //     .await
        //     .unwrap();
        // println!("{tx} tx");
        // let new_balance_owner = owner.client.get_balance(owner.key.address()).await.unwrap();
        // assert!(new_balance_owner < old_balance - amount); // Сумма перевода и комиссия
        // println!(
        //     "Owner баланс: \n\
        //     old: {old_balance}\n\
        //     new {new_balance_owner}"
        // );

        // let withdrow_balance = alice
        //     .contracts
        //     .bridge
        //     .status_withdraw()
        //     .call()
        //     .await
        //     .unwrap();
        // println!("Готово на вывод: {withdrow_balance}");

        // let old_balance = alice.client.get_balance(alice.key.address()).await.unwrap();
        // print!("Alice завершает вывод");
        // let tx = alice
        //     .contracts
        //     .bridge
        //     .withdraw()
        //     .send()
        //     .await
        //     .unwrap()
        //     .watch()
        //     .await
        //     .unwrap();
        // println!("{tx} tx");
        // let new_balance = alice.client.get_balance(alice.key.address()).await.unwrap();
        // println!(
        //     "Alice баланс: \n\
        //     old: {old_balance} eth\n\
        //     new {new_balance} eth"
        // );
        // assert!(new_balance > old_balance);

        // // Проверка баланса owner на то что он не изменился и снятие произошло при withdraw request
        // let balance_owner = owner.client.get_balance(owner.key.address()).await.unwrap();
        // assert_eq!(balance_owner, new_balance_owner);

        // let withdrow_balance = alice
        //     .contracts
        //     .bridge
        //     .status_withdraw()
        //     .call()
        //     .await
        //     .unwrap();
        // assert_eq!(withdrow_balance, Uint::ZERO);

        // println!("# # # Перевод ERC20 токена # # #");
        // println!("Тестирование переводов на L2 ERC20");

        // // # # # тестирование пополнения ERC20 токена # # #

        // println!("Проверка баланса owner ERC20");
        // let balance = owner
        //     .contracts
        //     .demo_erc20
        //     .balanceOf(owner.key.address())
        //     .call()
        //     .await
        //     .unwrap();
        // assert!(balance > Uint::from(2_000_000_000_000_u64));

        // println!("Проверка баланса ERC20 для BOB и Alice. Хватит ли на тесты");
        // for address in [alice.key.address(), bob.key.address()] {
        //     let balance = owner
        //         .contracts
        //         .demo_erc20
        //         .balanceOf(address)
        //         .call()
        //         .await
        //         .unwrap();
        //     println!("DemoERC20 {address}: {balance}");
        //     if balance > Uint::from(1_000_000_000) {
        //         continue;
        //     }
        //     owner
        //         .contracts
        //         .demo_erc20
        //         .transfer(address, Uint::from(1_000_000_000_000_u64)) // Такой перевод возможен только от владельца токена
        //         .send()
        //         .await
        //         .unwrap()
        //         .watch()
        //         .await
        //         .unwrap();
        // }

        // let amount_deposit = Uint::from(1_000_000);
        // let owner_address = owner.key.address();
        // let bridge_address = *owner.contracts.bridge.address();
        // let token = owner.contracts.demo_erc20;
        // let token_address = *token.address();
        // for (name, user) in [("alice", &alice), ("bob", &bob)] {
        //     let address = user.key.address();

        //     let old_balance_owner = token.balanceOf(owner_address).call().await.unwrap();
        //     let old_balance = token.balanceOf(address).call().await.unwrap();
        //     println!("DemoERC20 Owner: {old_balance_owner}");
        //     println!("DemoERC20 {name}: {old_balance}");

        //     println!("Перевод {name} {amount_deposit} ERC20 токенов на L2");

        //     // Передаём возможность контракту забрать токены в указаном количестве
        //     let tx = token
        //         .approve(bridge_address, amount_deposit)
        //         .send()
        //         .await
        //         .unwrap()
        //         .watch()
        //         .await
        //         .unwrap();
        //     println!("{name} одобрил перевод на Адрес контракта {tx}"); // Только контракт сможет забрать эти токины

        //     // Проверяем может ли контакт забрать эти токены
        //     let allow_amount = token
        //         .allowance(address, bridge_address)
        //         .call()
        //         .await
        //         .unwrap();

        //     assert_eq!(allow_amount, amount_deposit);

        //     // Переводим на L2
        //     let tx = user
        //         .contracts
        //         .bridge
        //         .deposit_erc20(token_address, address, amount_deposit)
        //         .send()
        //         .await
        //         .unwrap()
        //         .watch()
        //         .await
        //         .unwrap();
        //     println!("[{name}] tx deposit_erc20: {tx}");

        //     println!("Проверка OWNER баланса на L2 ERC20");
        //     let new_balance_owner = token.balanceOf(owner_address).call().await.unwrap();
        //     println!("DemoERC20 owner: {new_balance_owner}");
        //     assert_eq!(
        //         new_balance_owner,
        //         old_balance_owner + amount_deposit,
        //         "Баланс пользователя не изменился\n\
        //         {old_balance_owner}:{new_balance_owner}"
        //     );

        //     let new_balance = token.balanceOf(address).call().await.unwrap();
        //     println!("DemoERC20 {name}: {new_balance}");
        //     assert_eq!(new_balance, old_balance - amount_deposit,)
        // }

        // // withdraw ERC20
        // // Запрос может сделать только owner
        // let amount = Uint::from(10);
        // println!("Запрос на вывод {amount} ERC20 токенов от owner на");

        // let token = owner.contracts.demo_erc20;
        // let token_address = *token.address();
        // let bridge_address = *owner.contracts.bridge.address();
        // let owner_address = owner.key.address();

        // for (name, user) in [("alice", &alice), ("bob", &bob)] {
        //     let user_address = user.key.address();
        //     let old_balance_owner = token.balanceOf(owner_address).call().await.unwrap();
        //     let old_balance = token.balanceOf(user_address).call().await.unwrap();

        //     println!("Резервирование средств ERC20 на первод owner => {name}");
        //     let tx = owner
        //         .contracts
        //         .demo_erc20
        //         .approve(bridge_address, amount)
        //         .send()
        //         .await
        //         .unwrap()
        //         .watch()
        //         .await
        //         .unwrap();
        //     println!("approve: {tx}");

        //     let allow = token
        //         .allowance(owner_address, bridge_address)
        //         .call()
        //         .await
        //         .unwrap();
        //     assert!(allow >= amount);

        //     println!("Запрос на вывод {amount} ERC20 токенов от owner на {name}");
        //     let tx = owner
        //         .contracts
        //         .bridge
        //         .request_withdraw_erc20(token_address, user_address, amount)
        //         .send()
        //         .await
        //         .unwrap()
        //         .watch()
        //         .await
        //         .unwrap();
        //     println!("request withdraw tx: {tx}");

        //     let witrhdraw_amount = bridge
        //         .status_withdraw_erc20(token_address)
        //         .call()
        //         .await
        //         .unwrap();
        //     assert!(witrhdraw_amount >= amount);

        //     println!("Завершение перевода {amount} ERC20 токенов на {name}");
        //     let tx = bridge
        //         .withdraw_erc20(token_address)
        //         .send()
        //         .await
        //         .unwrap()
        //         .watch()
        //         .await
        //         .unwrap();
        //     println!("withdraw tx: {tx}");

        //     let new_balance_owner = token.balanceOf(owner_address).call().await.unwrap();
        //     assert_eq!(new_balance_owner, old_balance_owner - amount);

        //     let new_balance = token.balanceOf(user_address).call().await.unwrap();
        //     assert_eq!(new_balance, old_balance + amount);

        //     let witrhdraw_amount = bridge
        //         .status_withdraw_erc20(token_address)
        //         .call()
        //         .await
        //         .unwrap();
        //     assert_eq!(witrhdraw_amount, Uint::ZERO);
        // }
    }

    async fn test_bridge_deposit<T, A>(users: &mut [User<T, A>; 3])
    where
        T: alloy::providers::fillers::TxFiller,
        A: alloy::providers::Provider + Clone,
    {
        let [owner, alice, bob] = users;

        println!("# # # Перевод ETH # # #");
        println!("Создание отслеживание события переводов на L2 ETH");

        // Мониторинг событий пополнения депозита
        let (s, mut rec_deposit_events) = mpsc::channel(10);
        let deposit_handle = owner.deposit_event(s).await.unwrap();

        println!("переводов на L2 ETH");
        let amount = U256::from(1_000_000_000);
        let bridge_address = *owner.contracts.bridge.address();
        for (name, user) in [("alice", &alice), ("bob", &bob)] {
            println!();
            print!("Перевод для {name} {amount} ETH: ");

            let user_address = user.key.address();

            // Старый баланс ETH
            let old_balance = user.client.get_balance(user_address).await.unwrap();
            let old_balance_bridge = user.client.get_balance(bridge_address).await.unwrap();

            // Транзакция перевода на L2
            let tx = user.deposit(user_address, amount).await.unwrap();
            println!("deposit: {tx} tx");

            // Новый баланс ETH
            let new_balance = user.client.get_balance(user_address).await.unwrap();
            println!(
                "{name} balance:\n\
        old: {old_balance}\n\
        new: {new_balance}"
            );
            assert!(new_balance < old_balance - amount); // Сумма перевода и комиссия

            // owner баланс
            let new_balance_bridge = user.client.get_balance(bridge_address).await.unwrap();
            println!(
                "Bridge balance: \n\
        old: {old_balance_bridge}\n\
        new: {new_balance_bridge}"
            );
            assert_eq!(new_balance_bridge, old_balance_bridge + amount);
        }

        bob.deposit(alice.key.address(), Uint::from(9))
            .await
            .unwrap();

        println!();
        println!("Тестирования мониторинга событий");
        let t1 = rec_deposit_events.recv().await.unwrap();
        println!("Tx[1]: {t1:#?}");
        assert_eq!(t1.from, alice.key.address());
        assert_eq!(t1.to, alice.key.address());
        assert_eq!(t1.value, amount);

        let t2 = rec_deposit_events.recv().await.unwrap();
        println!("Tx[2]: {t2:#?}");
        assert_eq!(t2.from, bob.key.address());
        assert_eq!(t2.to, bob.key.address());
        assert_eq!(t2.value, amount);

        let t3 = rec_deposit_events.recv().await.unwrap();
        println!("Tx[3]: {t3:#?}");
        assert_eq!(t3.from, bob.key.address());
        assert_eq!(t3.to, alice.key.address());
        assert_eq!(t3.value, Uint::from(9));

        deposit_handle.abort();
    }

    async fn funds_erc20<T, A>(users: &mut [User<T, A>; 3])
    where
        T: alloy::providers::fillers::TxFiller,
        A: alloy::providers::Provider + Clone,
    {
        let [owner, alice, bob] = users;

        macro_rules! cr_tx {
            ($token:expr, $account_address:expr) => {
                let balance = $token.balanceOf($account_address).call().await.unwrap();
                println!("balance erc: {balance}");
                if balance < Unit::ETHER.wei() / Uint::from(10) {
                    $token
                        .transfer($account_address, Unit::ETHER.wei())
                        .send()
                        .await
                        .unwrap()
                        .watch()
                        .await
                        .unwrap();
                };
            };
        }

        cr_tx!(&owner.contracts.demo_erc20, alice.key.address());
        cr_tx!(&owner.contracts.demo_erc20, bob.key.address());
        cr_tx!(&owner.contracts.test_erc20, alice.key.address());
        cr_tx!(&owner.contracts.test_erc20, bob.key.address());
        cr_tx!(&owner.contracts.exm_erc20, alice.key.address());
        cr_tx!(&owner.contracts.exm_erc20, bob.key.address());
    }

    async fn test_erc20_without_bridge<T, A>(users: &mut [User<T, A>; 3])
    where
        T: alloy::providers::fillers::TxFiller,
        A: alloy::providers::Provider + Clone,
    {
        let [owner, alice, bob] = users;

        macro_rules! test_erc20 {
            ($user:expr, $token:expr) => {
                let token_address = *$token.address();
                if $user
                    .contracts
                    .bridge
                    .exist_bridge_erc20(token_address)
                    .call()
                    .await
                    .unwrap()
                {
                    println!("Токен уже добавлен в мост");
                    return;
                }

                let bridge_address = *$user.contracts.bridge.address();
                let user_address = $user.key.address();
                let amount = U256::from(1);

                $token
                    .approve(bridge_address, amount)
                    .from(user_address)
                    .send()
                    .await
                    .unwrap()
                    .watch()
                    .await
                    .unwrap();
                let tx = $user
                    .contracts
                    .bridge
                    .deposit_erc20(token_address, user_address, amount)
                    .from(user_address)
                    .send()
                    .await;
                println!("tx: {tx:#?}");
                assert!(tx.is_err(), "Ожидалась ошибка. Мост не создан");
            };
        }
        test_erc20!(&owner, &owner.contracts.demo_erc20);
        test_erc20!(&alice, &alice.contracts.test_erc20);
        test_erc20!(&bob, &bob.contracts.test_erc20);

        // @todo withdraw
    }

    async fn test_bridge_create_erc20<T, A>(users: &mut [User<T, A>; 3])
    where
        T: alloy::providers::fillers::TxFiller,
        A: alloy::providers::Provider + Clone,
    {
        let bridge_address = *users[0].contracts.bridge.address();

        #[allow(clippy::never_loop)]
        for (user, token_address) in users.iter().zip([
            *users[0].contracts.demo_erc20.address(),
            *users[0].contracts.test_erc20.address(),
            *users[0].contracts.exm_erc20.address(),
        ]) {
            if user
                .contracts
                .bridge
                .exist_bridge_erc20(token_address)
                .call()
                .await
                .unwrap()
            {
                println!("Токен {token_address} уже добавлен в мост. Нечего создавать");
                return;
            }
            let user_address = user.key.address();
            let cost = Unit::ETHER.wei();

            let res = user
                .contracts
                .bridge
                .create_bridge_erc20(token_address)
                .from(user_address)
                .value(cost - U256::from(1))
                .send()
                .await;

            assert!(res.is_err(), "{res:#?}");

            let old_user_balance = user.client.get_balance(user_address).await.unwrap();
            let old_bridge_balance = user.client.get_balance(bridge_address).await.unwrap();

            assert!(
                old_user_balance > cost,
                "Баланс кошелька {user_address} меньше чем 1_000_000_000_000"
            );

            println!("Создание моста для {token_address}");
            let tx = user
                .contracts
                .bridge
                .create_bridge_erc20(token_address)
                .from(user_address)
                .value(cost)
                .send()
                .await
                .unwrap()
                .watch()
                .await
                .unwrap();
            println!("tx: {tx:#?}");

            let new_user_balance = user.client.get_balance(user_address).await.unwrap();
            let new_bridge_balance = user.client.get_balance(bridge_address).await.unwrap();

            assert!(new_user_balance < old_user_balance - cost);
            assert_eq!(new_bridge_balance, old_bridge_balance + cost);

            let check_bridge = user
                .contracts
                .bridge
                .exist_bridge_erc20(token_address)
                .call()
                .await
                .unwrap();
            assert!(check_bridge);
        }
    }

    // #[traced_test]
    // #[tokio::test]
    // async fn test_token() {
    //     let accounts = read_accounts().unwrap();
    //     let owner = accounts[0].clone();
    //     let alice = accounts[1].clone();

    //     let owner_provider = ProviderBuilder::new()
    //         .wallet(owner.clone())
    //         .connect(RPC_URL)
    //         .await
    //         .unwrap();
    //     let alice.client = ProviderBuilder::new()
    //         .wallet(alice.clone())
    //         .connect(RPC_URL)
    //         .await
    //         .unwrap();

    //     // token
    //     let Contracts {
    //         demo_erc20: owner_token,
    //         ..
    //     } = init_contracts(owner_provider.clone()).await.unwrap();
    //     let owner_balance = owner_token.balanceOf(owner.key.address()).call().await.unwrap();
    //     dbg!(&owner_balance);

    //     let Contracts {
    //         demo_erc20: alice_token,
    //         ..
    //     } = init_contracts(alice.client.clone()).await.unwrap();
    //     let alice_balance = alice_token
    //         .balanceOf(alice.key.address())
    //         .call()
    //         .await
    //         .unwrap();
    //     dbg!(&alice_balance);

    //     owner_token
    //         .transfer(alice.key.address(), U256::from(10))
    //         .send()
    //         .await
    //         .unwrap()
    //         .watch()
    //         .await
    //         .unwrap();

    //     let owner_balance = owner_token.balanceOf(owner.key.address()).call().await.unwrap();
    //     dbg!(&owner_balance);
    //     let alice_balance = alice_token
    //         .balanceOf(alice.key.address())
    //         .call()
    //         .await
    //         .unwrap();
    //     dbg!(&alice_balance);
    // }

    // #[traced_test]
    // #[tokio::test]
    // async fn test_accounts() {
    //     let accounts = read_accounts().unwrap();

    //     let owner = accounts[0].clone();
    //     let owner_provider = ProviderBuilder::new()
    //         .wallet(owner.clone())
    //         .connect(RPC_URL)
    //         .await
    //         .unwrap();

    //     for acc in &accounts {
    //         println!(
    //             "Balance({}): {}",
    //             acc.address(),
    //             owner_provider.get_balance(acc.address()).await.unwrap()
    //         );
    //     }

    //     let Contracts {
    //         bridge: bridge_contract_owner,
    //         ..
    //     } = init_contracts(owner_provider.clone()).await.unwrap();

    //     // текущее значение
    //     // let value = Bridge_contract_owner.get().call().await.unwrap();
    //     // assert_eq!(value, Uint::ZERO);

    //     // Устанавливаем новое значение
    //     // let new_value = Uint::from(100);
    //     // Bridge_contract_owner
    //     //     .set(new_value)
    //     //     .send()
    //     //     .await
    //     //     .unwrap()
    //     //     .watch()
    //     //     .await
    //     //     .unwrap();

    //     // Проверяем что значение изменилось
    //     // let value = Bridge_contract_owner.get().call().await.unwrap();
    //     // assert_eq!(value, new_value);

    //     // Смотрим видно ли значение для alice
    //     let alice = accounts[1].clone();
    //     let alice.client = ProviderBuilder::new()
    //         .wallet(alice.clone())
    //         .connect(RPC_URL)
    //         .await
    //         .unwrap();

    //     let Contracts {
    //         bridge: bridge_contract_alice,
    //         ..
    //     } = init_contracts(alice.client.clone()).await.unwrap();
    //     // let value = Bridge_contract_alice.get().call().await.unwrap();
    //     // assert_eq!(value, new_value); // Значение единое для всех

    //     //
    //     let watch_send_event = bridge_contract_owner.Send_filter().watch().await.unwrap();
    //     let event_handle = tokio::spawn(async {
    //         use futures_util::StreamExt;

    //         let mut k = watch_send_event.into_stream();
    //         while let Some(Ok((v, l))) = k.next().await {
    //             println!("{v:#?}");
    //             dbg!(l);
    //         }
    //     });

    //     //

    //     let owner_old_balance = owner_provider.get_balance(owner.key.address()).await.unwrap();
    //     let alice_old_balance = alice.client
    //         .get_balance(alice.key.address())
    //         .await
    //         .unwrap();

    //     println!("Balances:");
    //     println!("owner: {}", owner_old_balance);
    //     println!("alice: {}", alice_old_balance);

    //     let send_amount = Uint::from(1_000_000);
    //     let tx_deposit = bridge_contract_alice
    //         .deposit(alice.key.address())
    //         .value(send_amount)
    //         .send()
    //         .await
    //         .unwrap()
    //         .watch()
    //         .await
    //         .unwrap();
    //     let owner_balance = owner_provider.get_balance(owner.key.address()).await.unwrap();
    //     let alice_balance = alice.client
    //         .get_balance(alice.key.address())
    //         .await
    //         .unwrap();
    //     println!("Balances:");
    //     println!("owner: {}", owner_balance);
    //     println!("alice: {}", alice_balance);

    //     assert_eq!(owner_balance, owner_old_balance + send_amount);
    //     assert!(alice_balance < alice_old_balance - send_amount);

    //     // let last_block = owner_provider
    //     //     .get_block(BlockId::Number(BlockNumberOrTag::Latest))
    //     //     .await
    //     //     .unwrap()
    //     //     .unwrap();

    //     // let last_block_header = last_block.header;

    //     let tx_receipt = owner_provider
    //         .get_transaction_receipt(tx_deposit)
    //         .await
    //         .unwrap()
    //         .unwrap();

    //     // owner_provider.get;
    //     dbg!(&tx_receipt);

    //     // bridge_contract_owner
    //     //     .check_up()
    //     //     .send()
    //     //     .await
    //     //     .unwrap()
    //     //     .watch()
    //     //     .await
    //     //     .unwrap();
    //     // bridge_contract_alice
    //     //     .check_up()
    //     //     .send()
    //     //     .await
    //     //     .unwrap()
    //     //     .watch()
    //     //     .await
    //     //     .unwrap();

    //     event_handle.abort();
    //     return;
    //     // let transport = web3::transports::Http::new("http://localhost:8545").unwrap();
    //     // let web3 = web3::Web3::new(transport);

    //     // // address: 0xd70e196eaea04eb065f8ad1acdc67c7ece43b7d9
    //     // // private key: cc4a7682c00703a233acab918d2e92dcdfb828663b4a8c84d4b561f6d3277ab3

    //     // // let acc = LocalWallet::decrypt_keystore("data/keystore/UTC--2025-05-12T06-52-14.764238799Z--d70e196eaea04eb065f8ad1acdc67c7ece43b7d9", "").unwrap();

    //     // let acc: Wallet<_> =
    //     //     Wallet::from_str("cc4a7682c00703a233acab918d2e92dcdfb828663b4a8c84d4b561f6d3277ab3")
    //     //         .unwrap();

    //     // println!("Calling accounts.");
    //     // let mut accounts = web3.eth().accounts().await.unwrap();

    //     // dbg!(acc.address());
    //     // dbg!(hex::encode(acc.signer().to_bytes().to_vec()));
    //     // println!("Accounts: {:?}", accounts);

    //     // return;

    //     // dbg!(&accounts);

    //     // let alice = accounts[0].clone();
    //     // let bob = accounts[1].clone();

    //     // dbg!(&alice, web3.eth().balance(alice, None).await);
    //     // dbg!(&bob, web3.eth().balance(bob, None).await);

    //     // dbg!(&web3.eth().block_number().await);

    //     // let tx = TransactionRequest {
    //     //     from: alice,
    //     //     to: Some(bob),
    //     //     value: Some(1_000_000.into()),
    //     //     // gas: Some(100_000.into()),
    //     //     ..TransactionRequest::default()
    //     // };

    //     // let t = web3.eth().send_transaction(tx).await.unwrap();

    //     // dbg!(&alice, web3.eth().balance(alice, None).await);
    //     // dbg!(&bob, web3.eth().balance(bob, None).await);

    //     // dbg!(
    //     //     web3.eth()
    //     //         .transaction(web3::types::TransactionId::Hash(t))
    //     //         .await
    //     // );

    //     // // Ожидаем подтверждения транзакции
    //     // loop {
    //     //     let receipt = web3.eth().transaction_receipt(t).await.unwrap();
    //     //     dbg!(&receipt);
    //     //     if receipt.is_some() {
    //     //         break;
    //     //     }
    //     // }
    //     // // web3.eth().block_with_txs(block)

    //     // let block_number = web3.eth().block_number().await.unwrap();
    //     // dbg!(&block_number);

    //     // dbg!(
    //     //     &web3
    //     //         .eth()
    //     //         .block_with_txs(web3::types::BlockId::Number(
    //     //             web3::types::BlockNumber::Finalized
    //     //         ))
    //     //         .await
    //     //         .unwrap()
    //     // );
    //     // dbg!(
    //     //     &web3
    //     //         .eth()
    //     //         .block_with_txs(web3::types::BlockId::Number(
    //     //             web3::types::BlockNumber::Latest
    //     //         ))
    //     //         .await
    //     //         .unwrap()
    //     // );
    //     // dbg!(
    //     //     &web3
    //     //         .eth()
    //     //         .block_with_txs(web3::types::BlockId::Number(
    //     //             web3::types::BlockNumber::Earliest
    //     //         ))
    //     //         .await
    //     //         .unwrap()
    //     // );
    //     // dbg!(
    //     //     &web3
    //     //         .eth()
    //     //         .block_with_txs(web3::types::BlockId::Number(
    //     //             web3::types::BlockNumber::Number(block_number)
    //     //         ))
    //     //         .await
    //     //         .unwrap()
    //     // );
    // }

    // #[traced_test]
    // #[tokio::test]
    // async fn test_find_bridge() {
    //     let accounts = read_accounts().unwrap();

    //     let owner_signer = accounts[0].clone();
    //     let owner_provider = ProviderBuilder::new()
    //         .wallet(owner_signer.clone())
    //         .connect(RPC_URL)
    //         .await
    //         .unwrap();

    //     let Contracts {
    //         bridge: bridge_contract_owner,
    //         ..
    //     } = init_contracts(owner_provider.clone()).await.unwrap();

    //     let bridge_address = *bridge_contract_owner.key.address();
    //     dbg!(bridge_address);

    //     // let latest_block = owner_provider.get_block_number().await.unwrap();
    //     let filter = Filter::new().from_block(0).address(bridge_address);
    //     // .event_signature(Bridge_contract_owner.);

    //     let logs = owner_provider.get_logs(&filter).await.unwrap();
    //     for log in &logs {
    //         if log.topic0() != Some(&Bridge::Send::SIGNATURE_HASH) {
    //             continue;
    //         }
    //         dbg!(&log.block_number);
    //         let t: Bridge::Send = log.log_decode().unwrap().inner.data;
    //         // let t = Bridge::BridgeEvents::decode_log(&log.inner);
    //         dbg!(t);
    //         // println!("log: {log:#?}");
    //     }

    //     // let mut block_number = 0;

    //     // let t = owner_provider
    //     //     .get_code_at(*Bridge_contract_owner.key.address())
    //     //     // (*Bridge_contract_owner.key.address(), U256::from(0))
    //     //     .await
    //     //     .unwrap();
    //     // dbg!(&t);

    //     // let watch_send_event = Bridge_contract_owner
    //     //     .Send_filter()
    //     //     .from_block(0)
    //     //     // .to_block(0)
    //     //     .watch()
    //     //     .await
    //     //     .unwrap();

    //     // use futures_util::StreamExt;
    //     // let mut k = watch_send_event.into_stream();
    //     // while let Some(Ok((v, l))) = k.next().await {
    //     //     println!("{v:#?}");
    //     //     dbg!(l);
    //     //     break;
    //     // }

    //     return;
    //     // loop {
    //     //     let Some(block) = owner_provider
    //     //         .get_block_by_number(BlockNumberOrTag::Number(block_number))
    //     //         .await
    //     //         .unwrap()
    //     //     else {
    //     //         break;
    //     //     };

    //     //     // let t = owner_provider.nb.await;
    //     //     // dbg!(&block);

    //     //     // let d = block.try_convert_transactions();
    //     //     // Bridge_contract_owner.event_filter()

    //     //     block_number += 1;
    //     // }

    //     //
    // }
}
